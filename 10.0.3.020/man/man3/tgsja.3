.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?tgsja 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
?tgsja \- Computes the generalized SVD of two upper triangular or trapezoidal matrices.
.SH SYNOPSIS
.PP
.B Fortran 77
.PP
\fBcall stgsja\fR(\fIjobu\fR, \fIjobv\fR, \fIjobq\fR, \fIm\fR, \fIp\fR, \fIn\fR, \fIk\fR, \fIl\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fItola\fR, \fItolb\fR, \fIalpha\fR, \fIbeta\fR, \fIu\fR, \fIldu\fR, \fIv\fR, \fIldv\fR, \fIq\fR, \fIldq\fR, \fIwork\fR, \fIncycle\fR, \fIinfo\fR)
.PP
\fBcall dtgsja\fR(\fIjobu\fR, \fIjobv\fR, \fIjobq\fR, \fIm\fR, \fIp\fR, \fIn\fR, \fIk\fR, \fIl\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fItola\fR, \fItolb\fR, \fIalpha\fR, \fIbeta\fR, \fIu\fR, \fIldu\fR, \fIv\fR, \fIldv\fR, \fIq\fR, \fIldq\fR, \fIwork\fR, \fIncycle\fR, \fIinfo\fR)
.PP
\fBcall ctgsja\fR(\fIjobu\fR, \fIjobv\fR, \fIjobq\fR, \fIm\fR, \fIp\fR, \fIn\fR, \fIk\fR, \fIl\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fItola\fR, \fItolb\fR, \fIalpha\fR, \fIbeta\fR, \fIu\fR, \fIldu\fR, \fIv\fR, \fIldv\fR, \fIq\fR, \fIldq\fR, \fIwork\fR, \fIncycle\fR, \fIinfo\fR)
.PP
\fBcall ztgsja\fR(\fIjobu\fR, \fIjobv\fR, \fIjobq\fR, \fIm\fR, \fIp\fR, \fIn\fR, \fIk\fR, \fIl\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fItola\fR, \fItolb\fR, \fIalpha\fR, \fIbeta\fR, \fIu\fR, \fIldu\fR, \fIv\fR, \fIldv\fR, \fIq\fR, \fIldq\fR, \fIwork\fR, \fIncycle\fR, \fIinfo\fR)
.PP
.B Fortran 95
.PP
\fBcall tgsja\fR(\fIa\fR, \fIb\fR, \fItola\fR, \fItolb\fR, \fIk\fR, \fIl\fR[,\fIu\fR] [,\fIv\fR] [,\fIq\fR] [,\fIjobu\fR] [,\fIjobv\fR] [,\fIjobq\fR] [,\fIalpha\fR] [,\fIbeta\fR] [,\fIncycle\fR] [,\fIinfo\fR])
.SH INPUT PARAMETERS

.TP 10
\fBjobu\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'U\'\fR, \fB\'I\'\fR, or \fB\'N\'\fR. 
.IP
If \fIjobu\fR = \fB\'U\'\fR, \fIu\fR must contain an orthogonal/unitary matrix \fIU\fR1 on entry. 
.IP
If \fIjobu\fR = \fB\'I\'\fR, \fIu\fR is initialized to the unit matrix. 
.IP
If \fIjobu\fR = \fB\'N\'\fR, \fIu\fR is not computed.
.TP 10
\fBjobv\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'V\'\fR, \fB\'I\'\fR, or \fB\'N\'\fR. 
.IP
If \fIjobv\fR = \fB\'V\'\fR, \fIv\fR must contain an orthogonal/unitary matrix \fIV\fR1 on entry. 
.IP
If \fIjobv\fR = \fB\'I\'\fR, \fIv\fR is initialized to the unit matrix. 
.IP
If \fIjobv\fR = \fB\'N\'\fR, \fIv\fR is not computed.
.TP 10
\fBjobq\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'Q\'\fR, \fB\'I\'\fR, or \fB\'N\'\fR. 
.IP
If \fIjobq\fR = \fB\'Q\'\fR, \fIq\fR must contain an orthogonal/unitary matrix \fIQ\fR1 on entry. 
.IP
If \fIjobq\fR = \fB\'I\'\fR, \fIq\fR is initialized to the unit matrix. 
.IP
If \fIjobq\fR = \fB\'N\'\fR, \fIq\fR is not computed.
.TP 10
\fBm\fR
.NL
\fBINTEGER\fR. The number of rows of the matrix \fIA\fR (\fIm\fR\(>= 0).
.TP 10
\fBp\fR
.NL
\fBINTEGER\fR. The number of rows of the matrix \fIB\fR (\fIp\fR\(>= 0).
.TP 10
\fBn\fR
.NL
\fBINTEGER\fR. The number of columns of the matrices \fIA\fR and \fIB\fR (\fIn\fR\(>= 0).
.TP 10
\fBk\fR, \fBl\fR
.NL
\fBINTEGER\fR. Specify the subblocks in the input matrices \fIA\fR and \fIB\fR, whose GSVD is computed.
.TP 10
\fBa\fR,\fBb\fR,\fBu\fR,\fBv\fR,\fBq\fR,\fBwork\fR
.NL
\fBREAL\fR for \fBstgsja\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdtgsja\fR
.IP
\fBCOMPLEX\fR for \fBctgsja\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBztgsja\fR. 
.IP
Arrays: 
.IP
\fIa\fR(\fIlda\fR,*) contains the \fIm\fR-by-\fIn\fR matrix \fIA\fR. 
.IP
The second dimension of \fIa\fR must be at least max(1, \fIn\fR).
.IP
\fIb\fR(\fIldb\fR,*) contains the \fIp\fR-by-\fIn\fR matrix \fIB\fR. 
.IP
The second dimension of \fIb\fR must be at least max(1, \fIn\fR).
.IP
If \fIjobu\fR = \fB\'U\'\fR, \fIu\fR(\fIldu\fR,*) must contain a matrix \fIU\fR1 (usually the orthogonal/unitary matrix returned by \fB?ggsvp\fR). 
.IP
The second dimension of \fIu\fR must be at least max(1, \fIm\fR).
.IP
If \fIjobv\fR = \fB\'V\'\fR, \fIv\fR(\fIldv\fR,*) must contain a matrix \fIV\fR1 (usually the orthogonal/unitary matrix returned by \fB?ggsvp\fR). 
.IP
The second dimension of \fIv\fR must be at least max(1, \fIp\fR).
.IP
If \fIjobq\fR = \fB\'Q\'\fR, \fIq\fR(\fIldq\fR,*) must contain a matrix \fIQ\fR1 (usually the orthogonal/unitary matrix returned by \fB?ggsvp\fR). 
.IP
The second dimension of \fIq\fR must be at least max(1, \fIn\fR).
.IP
\fIwork\fR(*\fI\fR) is a workspace array. 
.IP
The dimension of \fIwork\fR must be at least max(1, 2\fIn\fR).
.TP 10
\fBlda\fR
.NL
\fBINTEGER\fR. The first dimension of \fIa\fR; at least max(1, \fIm\fR).
.TP 10
\fBldb\fR
.NL
\fBINTEGER\fR. The first dimension of \fIb\fR; at least max(1, \fIp\fR).
.TP 10
\fBldu\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIu\fR . 
.IP
\fIldu\fR\(>= max(1, \fIm\fR) if \fIjobu\fR = \fB\'U\'\fR; \fIldu\fR\(>= 1 otherwise.
.TP 10
\fBldv\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIv\fR . 
.IP
\fIldv\fR\(>= max(1, \fIp\fR) if \fIjobv\fR = \fB\'V\'\fR; \fIldv\fR\(>= 1 otherwise.
.TP 10
\fBldq\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIq\fR . 
.IP
\fIldq\fR\(>= max(1, \fIn\fR) if \fIjobq\fR = \fB\'Q\'\fR; \fIldq\fR\(>= 1 otherwise.
.TP 10
\fBtola\fR, \fBtolb\fR
.NL
\fBREAL\fR for single-precision flavors
.IP
\fBDOUBLE PRECISION\fR for double-precision flavors.
.IP
\fItola\fR and \fItolb\fR are the convergence criteria for the Jacobi-Kogbetliantz iteration procedure. Generally, they are the same as used in \fB?ggsvp\fR: 
.IP
\fItola\fR = max(\fIm\fR, \fIn\fR)*|\fIA\fR|*MACHEPS, 
.IP
\fItolb\fR = max(\fIp\fR, \fIn\fR)*|\fIB\fR|*MACHEPS.
.SH OUTPUT PARAMETERS

.TP 10
\fBa\fR
.NL
On exit, \fIa\fR(\fIn\fR-\fIk\fR+1:\fIn\fR, 1:min(\fIk\fR+\fIl\fR, \fIm\fR)) contains the triangular matrix \fIR\fR or part of \fIR\fR.
.TP 10
\fBb\fR
.NL
On exit, if necessary, \fIb\fR(\fIm\fR-\fIk\fR+1: \fIl\fR, \fIn\fR+\fIm\fR-\fIk\fR-\fIl\fR+1: \fIn\fR)) contains a part of \fIR\fR.
.TP 10
\fBalpha\fR, \fBbeta\fR
.NL
\fBREAL\fR for single-precision flavors
.IP
\fBDOUBLE PRECISION\fR for double-precision flavors. 
.IP
Arrays, \fBDIMENSION\fR at least max(1, \fIn\fR). Contain the generalized singular value pairs of \fIA\fR and \fIB\fR:
.IP
\fIalpha\fR(1:\fIk\fR) = 1, 
.IP
\fIbeta\fR(1:\fIk\fR) = 0,
.IP
and if \fIm\fR-\fIk\fR-\fIl\fR\(>= 0, 
.IP
\fIalpha\fR(\fIk\fR+1:\fIk\fR+\fIl\fR) = diag(\fIC\fR), 
.IP
\fIbeta\fR(\fIk\fR+1:\fIk\fR+\fIl\fR) = diag(\fIS\fR),
.IP
or if \fIm\fR-\fIk\fR-\fIl\fR < 0, 
.IP
\fIalpha\fR(\fIk\fR+1:\fIm\fR)= \fIC\fR, \fIalpha\fR(\fIm\fR+1:\fIk\fR+\fIl\fR)=0
.IP
\fIbeta\fR(\fIK\fR+1:\fIM\fR) = \fIS\fR, 
.IP
\fIbeta\fR(\fIm\fR+1:\fIk\fR+\fIl\fR) = 1.
.IP
Furthermore, if \fIk\fR+\fIl\fR < \fIn\fR, 	
.IP
\fIalpha\fR(\fIk\fR+\fIl\fR+1:\fIn\fR)= 0 and	
.IP
\fIbeta\fR(\fIk\fR+\fIl\fR+1:\fIn\fR) = 0.
.TP 10
\fBu\fR
.NL
If \fIjobu\fR = \fB\'I\'\fR, \fIu\fR contains the orthogonal/unitary matrix \fIU\fR. 
.IP
If \fIjobu\fR = \fB\'U\'\fR, \fIu\fR contains the product \fIU\fR1\fI*U\fR.
.IP
If \fIjobu\fR = \fB\'N\'\fR, \fIu\fR is not referenced.
.TP 10
\fBv\fR
.NL
If \fIjobv\fR = \fB\'I\'\fR, \fIv\fR contains the orthogonal/unitary matrix \fIU\fR. 
.IP
If \fIjobv\fR = \fB\'V\'\fR, \fIv\fR contains the product \fIV\fR1\fI*V\fR.
.IP
If \fIjobv\fR = \fB\'N\'\fR, \fIv\fR is not referenced.
.TP 10
\fBq\fR
.NL
If \fIjobq\fR = \fB\'I\'\fR, \fIq\fR contains the orthogonal/unitary matrix \fIU\fR. 
.IP
If \fIjobq\fR = \fB\'Q\'\fR, \fIq\fR contains the product \fIQ\fR1\fI*Q\fR.
.IP
If \fIjobq\fR = \fB\'N\'\fR, \fIq\fR is not referenced.
.TP 10
\fBncycle\fR
.NL
\fBINTEGER\fR. The number of cycles required for convergence.
.TP 10
\fBinfo\fR
.NL
\fBINTEGER\fR. 
.IP
If \fIinfo\fR = 0, the execution is successful. 
.IP
If \fIinfo\fR = \fI-i\fR, the \fIi\fR-th parameter had an illegal value. 
.IP
If \fIinfo\fR = 1, the procedure does not converge after MAXIT cycles.
.SH FORTRAN 95 INTERFACE NOTES
.PP
.PP
Routines in Fortran 95 interface have fewer arguments in the calling sequence than their Fortran 77 counterparts. For general conventions applied to skip redundant or restorable arguments, see Fortran 95  Interface Conventions.
.PP
Specific details for the routine \fBtgsja\fR interface are the following:
.TP 10
\fBa\fR
.NL
Holds the matrix \fIA\fR of size (\fIm,n\fR).
.TP 10
\fBb\fR
.NL
Holds the matrix \fIB\fR of size (\fIp,n\fR).
.TP 10
\fBu\fR
.NL
Holds the matrix \fIU\fR of size (\fIm,m\fR).
.TP 10
\fBv\fR
.NL
Holds the matrix \fIV\fR of size (\fIp,p\fR).
.TP 10
\fBq\fR
.NL
Holds the matrix \fIQ\fR of size (\fIn,n\fR).
.TP 10
\fBalpha\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBbeta\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBjobu\fR
.NL
If omitted, this argument is restored based on the presence of argument \fIu\fR as follows: 
.IP
\fIjobu\fR = \fB\'U\'\fR, if \fIu\fR is present, 
.IP
\fIjobu\fR = \fB\'N\'\fR, if \fIu\fR is omitted. 
.IP
If present, \fIjobu\fR must be equal to \fB\'I\'\fR or \fB\'U\'\fR and the argument \fIu\fR must also be present. 
.IP
Note that there will be an error condition if \fIjobu\fR is present and \fIu\fR omitted.
.TP 10
\fBjobv\fR
.NL
If omitted, this argument is restored based on the presence of argument \fIv\fR as follows: 
.IP
\fIjobv\fR = \fB\'V\'\fR, if \fIv\fR is present, 
.IP
\fIjobv\fR = \fB\'N\'\fR, if \fIv\fR is omitted. 
.IP
If present, \fIjobv\fR must be equal to \fB\'I\'\fR or \fB\'V\'\fR and the argument \fIv\fR must also be present. 
.IP
Note that there will be an error condition if \fIjobv\fR is present and \fIv\fR omitted.
.TP 10
\fBjobq\fR
.NL
If omitted, this argument is restored based on the presence of argument \fIq\fR as follows: 
.IP
\fIjobq\fR = \fB\'Q\'\fR, if \fIq\fR is present, 
.IP
\fIjobq\fR = \fB\'N\'\fR, if \fIq\fR is omitted. 
.IP
If present, \fIjobq\fR must be equal to \fB\'I\'\fR or \fB\'Q\'\fR and the argument \fIq\fR must also be present. 
.IP
Note that there will be an error condition if \fIjobq\fR is present and \fIq\fR omitted.
