.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?tgexc 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
?tgexc \- Reorders the generalized Schur decomposition of a pair of matrices (A,B) so that one diagonal block of (A,B) moves to another row index.
.SH SYNOPSIS
.PP
.B Fortran 77
.PP
\fBcall stgexc\fR(\fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIifst\fR, \fIilst\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall dtgexc\fR(\fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIifst\fR, \fIilst\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall ctgexc\fR(\fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIifst\fR, \fIilst\fR, \fIinfo\fR)
.PP
\fBcall ztgexc\fR(\fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIifst\fR, \fIilst\fR, \fIinfo\fR)
.PP
.B Fortran 95
.PP
\fBcall tgexc\fR(\fIa\fR, \fIb\fR[,\fIifst\fR] [,\fIilst\fR] [,\fIz\fR] [,\fIq\fR] [,\fIinfo\fR])
.SH INPUT PARAMETERS

.TP 10
\fBwantq\fR, \fBwantz\fR
.NL
\fBLOGICAL\fR. 
.IP
If \fIwantq\fR = \fB.TRUE.\fR, update the left transformation matrix \fIQ\fR;
.IP
If \fIwantq\fR = \fB.FALSE.\fR, do not update \fIQ\fR;
.IP
If \fIwantz\fR = \fB.TRUE.\fR, update the right transformation matrix \fIZ\fR;
.IP
If \fIwantz\fR = \fB.FALSE.\fR, do not update \fIZ\fR.
.TP 10
\fBn\fR
.NL
\fBINTEGER\fR. The order of the matrices \fIA\fR and \fIB\fR (\fIn\fR\(>= 0).
.TP 10
\fBa\fR, \fBb\fR, \fBq\fR, \fB\fR
.NL
\fBREAL\fR for \fBstgexc\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdtgexc\fR
.IP
\fBCOMPLEX\fR for \fBctgexc\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBztgexc\fR. 
.IP
Arrays: 
.IP
\fIa\fR(\fIlda\fR,*) contains the matrix \fIA\fR. 
.IP
The second dimension of \fIa\fR must be at least max(1, \fIn\fR).
.IP
\fIb\fR(\fIldb\fR,*) contains the matrix \fIB\fR. The second dimension of \fIb\fR must be at least max(1, \fIn\fR).
.IP
\fIq\fR (\fIldq\fR,*) 
.IP
If \fIwantq\fR = \fB.FALSE.\fR, then \fIq\fR is not referenced. 
.IP
If \fIwantq\fR = \fB.TRUE.\fR, then \fIq\fR must contain the orthogonal/unitary matrix \fIQ\fR. 
.IP
The second dimension of \fIq\fR must be at least max(1, \fIn\fR).
.IP
\fIz\fR (\fIldz\fR,*) 
.IP
If \fIwantz\fR = \fB.FALSE.\fR, then \fIz\fR is not referenced. 
.IP
If \fIwantz\fR = \fB.TRUE.\fR, then \fIz\fR must contain the orthogonal/unitary matrix \fIZ\fR. 
.IP
The second dimension of \fIz\fR must be at least max(1, \fIn\fR).
.TP 10
\fBlda\fR
.NL
\fBINTEGER\fR. The first dimension of \fIa\fR; at least max(1, \fIn\fR).
.TP 10
\fBldb\fR
.NL
\fBINTEGER\fR. The first dimension of \fIb\fR; at least max(1, \fIn\fR).
.TP 10
\fBldq\fR
.NL
\fBINTEGER\fR. The first dimension of \fIq\fR; 
.IP
If \fIwantq\fR = \fB.FALSE.\fR, then \fIldq\fR\(>= 1. 
.IP
If \fIwantq\fR = \fB.TRUE.\fR, then \fIldq\fR\(>= max(1, \fIn\fR).
.TP 10
\fBldz\fR
.NL
\fBINTEGER\fR. The first dimension of \fIz\fR; 
.IP
If \fIwantz\fR = \fB.FALSE.\fR, then \fIldz\fR\(>= 1. 
.IP
If \fIwantz\fR = \fB.TRUE.\fR, then \fIldz\fR\(>= max(1, \fIn\fR).
.TP 10
\fBifst\fR, \fBilst\fR
.NL
\fBINTEGER\fR. Specify the reordering of the diagonal blocks of (\fIA\fR, \fIB\fR). The block with row index \fIifst\fR is moved to row \fIilst\fR, by a sequence of swapping between adjacent blocks. Constraint: 1 \(<=\fIifst\fR, \fIilst\fR\(<=\fIn\fR. 
.TP 10
\fBwork\fR
.NL
\fBREAL\fR for \fBstgexc\fR;
.IP
\fBDOUBLE PRECISION\fR for \fBdtgexc\fR. 
.IP
Workspace array, \fBDIMENSION\fR (\fIlwork\fR). Used in real flavors only.
.TP 10
\fBlwork\fR
.NL
\fBINTEGER\fR. The dimension of \fIwork\fR; must be at least 4\fIn\fR +16.
.IP
If \fIlwork\fR = -1, then a workspace query is assumed; the routine only calculates the optimal size of the \fIwork\fR array, returns this value as the first entry of the \fIwork\fR array, and no error message related to \fIlwork\fR is issued by \fBxerbla\fR. 
.SH OUTPUT PARAMETERS

.TP 10
\fBa\fR, \fBb\fR
.NL
Overwritten by the updated matrices \fIA\fR and \fIB\fR.
.TP 10
\fBifst\fR, \fBilst\fR
.NL
Overwritten for real flavors only. 
.IP
If \fIifst\fR pointed to the second row of a 2 by 2 block on entry, it is changed to point to the first row; \fIilst\fR always points to the first row of the block in its final position (which may differ from its input value by \(+-1).
.TP 10
\fBinfo\fR
.NL
\fBINTEGER\fR. 
.IP
If \fIinfo\fR = 0, the execution is successful. 
.IP
If \fIinfo\fR = \fI-i\fR, the \fIi\fR-th parameter had an illegal value. 
.IP
If \fIinfo\fR = 1, the transformed matrix pair (\fIA\fR, \fIB\fR) would be too far from generalized Schur form; the problem is ill-conditioned. (\fIA\fR, \fIB\fR) may have been partially reordered, and \fIilst\fR points to the first row of the current position of the block being moved.
.SH FORTRAN 95 INTERFACE NOTES
.PP
.PP
Routines in Fortran 95 interface have fewer arguments in the calling sequence than their Fortran 77 counterparts. For general conventions applied to skip redundant or restorable arguments, see Fortran 95  Interface Conventions.
.PP
Specific details for the routine \fBtgexc\fR interface are the following:
.TP 10
\fBa\fR
.NL
Holds the matrix \fIA\fR of size (\fIn,n\fR).
.TP 10
\fBb\fR
.NL
Holds the matrix \fIB\fR of size (\fIn,n\fR).
.TP 10
\fBz\fR
.NL
Holds the matrix \fIZ\fR of size (\fIn,n\fR).
.TP 10
\fBq\fR
.NL
Holds the matrix \fIQ\fR of size (\fIn,n\fR).
.TP 10
\fBwantq\fR
.NL
Restored based on the presence of the argument \fIq\fR as follows: 
.IP
\fIwantq\fR = \fB.TRUE\fR, if \fIq\fR is present, 
.IP
\fIwantq\fR = \fB.FALSE\fR, if \fIq\fR is omitted.
.TP 10
\fBwantz\fR
.NL
Restored based on the presence of the argument \fIz\fR as follows: 
.IP
\fIwantz\fR = \fB.TRUE\fR, if \fIz\fR is present, 
.IP
\fIwantz\fR = \fB.FALSE\fR, if z is omitted.
