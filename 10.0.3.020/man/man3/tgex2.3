.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?tgex2 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
?tgex2 \- Swaps adjacent diagonal blocks in an upper (quasi) triangular matrix pair by an orthogonal/unitary equivalence transformation.
.SH SYNOPSIS
.PP
\fBcall stgex2\fR( \fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIj1\fR, \fIn1\fR, \fIn2\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall dtgex2\fR( \fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIj1\fR, \fIn1\fR, \fIn2\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall ctgex2\fR( \fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIj1\fR, \fIinfo\fR)
.PP
\fBcall ztgex2\fR( \fIwantq\fR, \fIwantz\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIq\fR, \fIldq\fR, \fIz\fR, \fIldz\fR, \fIj1\fR, \fIinfo\fR)
.SH INPUT PARAMETERS

.TP 10
\fBwantq\fR
.NL
\fBLOGICAL\fR. 
.IP
If \fIwantq\fR =  \fB.TRUE.\fR : update the left transformation matrix \fIQ\fR;
.IP
If \fIwantq\fR =  \fB.FALSE.\fR : do not update \fIQ\fR.
.TP 10
\fBwantz\fR
.NL
\fBLOGICAL\fR. 
.IP
If \fIwantz\fR =  \fB.TRUE.\fR : update the right transformation matrix \fIZ\fR;
.IP
If \fIwantz\fR = \fB.FALSE.\fR: do not update \fIZ\fR.
.TP 10
\fBn\fR
.NL
\fBINTEGER\fR. The order of the matrices \fIA\fR and \fIB\fR. \fIn\fR\(>= 0.
.TP 10
\fBa\fR, \fBb\fR
.NL
\fBREAL\fR for \fBstgex2\fR\fBDOUBLE PRECISION\fR for \fBdtgex2\fR
.IP
\fBCOMPLEX\fR for \fBctgex2\fR
.IP
\fBCOMPLEX*16\fR for \fBztgex2\fR.
.IP
Arrays, \fBDIMENSION\fR (\fIlda\fR, \fIn\fR) and (\fIldb\fR, \fIn\fR), respectively. 
.IP
On entry, the matrices \fIA\fR and \fIB\fR in the pair (\fIA\fR, \fIB\fR).
.TP 10
\fBlda\fR
.NL
\fBINTEGER\fR. The leading dimension of the array \fIa\fR. \fIlda\fR\(>= max(1,\fIn\fR).
.TP 10
\fBldb\fR
.NL
\fBINTEGER\fR. The leading dimension of the array \fIb\fR. \fIldb\fR\(>= max(1,\fIn\fR).
.TP 10
\fBq\fR, \fBz\fR
.NL
\fBREAL\fR for \fBstgex2\fR\fBDOUBLE PRECISION\fR for \fBdtgex2\fR
.IP
\fBCOMPLEX\fR for \fBctgex2\fR
.IP
\fBCOMPLEX*16\fR for \fBztgex2\fR.
.IP
Arrays, \fBDIMENSION\fR (\fIldq\fR, \fIn\fR) and (\fIldz\fR, \fIn\fR), respectively. 
.IP
On entry, if \fIwantq\fR = \fB.TRUE.\fR, \fIq\fR contains the orthogonal/unitary matrix \fIQ\fR, and if \fIwantz\fR = \fB.TRUE.\fR, \fIz\fR contains the orthogonal/unitary matrix \fIZ\fR.
.TP 10
\fBldq\fR
.NL
\fBINTEGER\fR. The leading dimension of the array \fIq\fR. \fIldq\fR\(>= 1. 
.IP
If \fIwantq\fR = \fB.TRUE.\fR, \fIldq\fR\(>=\fIn\fR.
.TP 10
\fBldz\fR
.NL
\fBINTEGER\fR. The leading dimension of the array \fIz\fR. \fIldz\fR\(>= 1. 
.IP
If \fIwantz\fR = \fB.TRUE.\fR, \fIldz\fR\(>=\fIn\fR.
.TP 10
\fBj1\fR
.NL
\fBINTEGER\fR. 
.IP
The index to the first block (\fIA\fR11, \fIB\fR11). 1 \(<= \fIj1\fR \(<= \fIn\fR.
.TP 10
\fBn1\fR
.NL
\fBINTEGER\fR. Used with real flavors only. The order of the first block (\fIA\fR11, \fIB\fR11). \fIn1\fR = 0, 1 or 2.
.TP 10
\fBn2\fR
.NL
\fBINTEGER\fR. Used with real flavors only. The order of the second block (\fIA\fR22, \fIB\fR22). \fIn2\fR = 0,  1 or 2.
.TP 10
\fBwork\fR
.NL
\fBREAL\fR for \fBstgex2\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdtgex2\fR.
.IP
Workspace array, \fBDIMENSION\fR(max(1,\fIlwork\fR)). Used with real flavors only.
.TP 10
\fBlwork\fR
.NL
\fBINTEGER\fR. The dimension of the array \fIwork\fR. 
.IP
\fIlwork\fR\(>=max(\fIn\fR*(\fIn2\fR+\fIn1\fR), 2*(\fIn2\fR+\fIn1\fR)**2)
.SH OUTPUT PARAMETERS

.TP 10
\fBa\fR
.NL
On exit, the updated matrix \fIA\fR.
.TP 10
\fBB\fR
.NL
On exit, the updated matrix \fIB\fR.
.TP 10
\fBQ\fR
.NL
On exit, the updated matrix \fIQ\fR. 
.IP
Not referenced if \fIwantq\fR = \fB.FALSE.\fR.
.TP 10
\fBz\fR
.NL
On exit, the updated matrix \fIZ\fR. 
.IP
Not referenced if \fIwantz\fR = \fB.FALSE.\fR.
.TP 10
\fBinfo\fR
.NL
\fBINTEGER\fR. 
.IP
=0: Successful exit For \fBstgex2\fR/\fBdtgex2\fR: If \fIinfo\fR = 1, the transformed matrix (\fIA\fR, \fIB\fR) would be too far from generalized Schur form; the blocks are not swapped and (\fIA\fR, \fIB\fR) and (\fIQ\fR, \fIZ\fR) are unchanged. The problem of swapping is too ill-conditioned. If \fIinfo\fR = -16: \fIlwork\fR is too small. Appropriate value for \fIlwork\fR is returned in \fIwork\fR(1).
.IP
For \fBctgex2\fR/\fBztgex2\fR:
.IP
If \fIinfo\fR = 1, the transformed matrix pair (\fIA\fR, \fIB\fR) would be too far from generalized Schur form; the problem is ill-conditioned.
