.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?ggev 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
?ggev \- Computes the generalized eigenvalues, and the left and/or right generalized eigenvectors for a pair of nonsymmetric matrices.
.SH SYNOPSIS
.PP
.B Fortran 77
.PP
\fBcall sggev\fR(\fIjobvl\fR, \fIjobvr\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIalphar\fR, \fIalphai\fR, \fIbeta\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall dggev\fR(\fIjobvl\fR, \fIjobvr\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIalphar\fR, \fIalphai\fR, \fIbeta\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIwork\fR, \fIlwork\fR, \fIinfo\fR)
.PP
\fBcall cggev\fR(\fIjobvl\fR, \fIjobvr\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIalpha\fR, \fIbeta\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIwork\fR, \fIlwork\fR, \fIrwork\fR, \fIinfo\fR)
.PP
\fBcall zggev\fR(\fIjobvl\fR, \fIjobvr\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIb\fR, \fIldb\fR, \fIalpha\fR, \fIbeta\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIwork\fR, \fIlwork\fR, \fIrwork\fR, \fIinfo\fR)
.PP
.B Fortran 95
.PP
\fBcall ggev\fR(\fIa\fR, \fIb\fR, \fIalphar\fR, \fIalphai\fR, \fIbeta\fR[,\fIvl\fR] [,\fIvr\fR] [,\fIinfo\fR])
.PP
\fBcall ggev\fR(\fIa\fR, \fIb\fR, \fIalpha\fR, \fIbeta\fR[, \fIvl\fR] [,\fIvr\fR] [,\fIinfo\fR])
.SH INPUT PARAMETERS

.TP 10
\fBjobvl\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR or \fB\'V\'\fR. 
.IP
If \fIjobvl\fR = \fB\'N\'\fR, the left generalized eigenvectors are not computed; 
.IP
If \fIjobvl\fR = \fB\'V\'\fR, the left generalized eigenvectors are computed.
.TP 10
\fBjobvr\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR or \fB\'V\'\fR. 
.IP
If \fIjobvr\fR = \fB\'N\'\fR, the right generalized eigenvectors are not computed; 
.IP
If \fIjobvr\fR = \fB\'V\'\fR, the right generalized eigenvectors are computed.
.TP 10
\fBn\fR
.NL
\fBINTEGER\fR. The order of the matrices \fIA\fR, \fIB\fR, \fIvl\fR, and \fIvr\fR (\fIn\fR\(>= 0). 
.TP 10
\fBa\fR, \fBb\fR, \fBwork\fR
.NL
\fBREAL\fR for \fBsggev\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdggev\fR
.IP
\fBCOMPLEX\fR for \fBcggev\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzggev\fR. 
.IP
Arrays: 
.IP
\fIa\fR(\fIlda\fR,*) is an array containing the \fIn\fR-by-\fIn\fR matrix \fIA\fR (first of the pair of matrices). 
.IP
The second dimension of \fIa\fR must be at least max(1, \fIn\fR).
.IP
\fIb\fR(\fIldb\fR,*) is an array containing the \fIn\fR-by-\fIn\fR matrix \fIB\fR (second of the pair of matrices). 
.IP
The second dimension of \fIb\fR must be at least max(1, \fIn\fR).
.IP
\fIwork\fR is a workspace array, its dimension max(1, \fBlwork\fR).
.TP 10
\fBlda\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIa\fR. Must be at least max(1, \fIn\fR).
.TP 10
\fBldb\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIb\fR. Must be at least max(1, \fIn\fR).
.TP 10
\fBldvl\fR, \fBldvr\fR
.NL
\fBINTEGER\fR. The first dimensions of the output matrices \fIvl\fR and \fIvr\fR, respectively. 
.IP
Constraints:
.IP
\fIldvl\fR\(>= 1. If \fIjobvl\fR = \fB\'V\'\fR, \fIldvl\fR\(>= max(1, \fIn\fR).
.IP
\fIldvr\fR\(>= 1. If \fIjobvr\fR = \fB\'V\'\fR, \fIldvr\fR\(>= max(1, \fIn\fR). 
.TP 10
\fBlwork\fR
.NL
\fBINTEGER\fR. 
.IP
The dimension of the array \fIwork\fR.
.IP
\fIlwork\fR\(>= max(1, 8\fIn\fR+16) for real flavors;
.IP
\fIlwork\fR\(>= max(1, 2\fIn\fR) for complex flavors. 
.IP
For good performance, \fIlwork\fR must generally be larger.
.IP
If \fIlwork\fR = -1, then a workspace query is assumed; the routine only calculates the optimal size of the \fIwork\fR array, returns this value as the first entry of the \fIwork\fR array, and no error message related to \fIlwork\fR is issued by \fBxerbla\fR.
.TP 10
\fBrwork\fR
.NL
\fBREAL\fR for \fBcggev\fR
.IP
\fBDOUBLE PRECISION\fR for \fBzggev\fR
.IP
Workspace array, \fBDIMENSION\fR at least max(1, 8\fIn\fR). 
.IP
This array is used in complex flavors only.
.SH OUTPUT PARAMETERS

.TP 10
\fBa\fR, \fBb\fR
.NL
On exit, these arrays have been overwritten. 
.TP 10
\fBalphar\fR, \fBalphai\fR
.NL
\fBREAL\fR for \fBsggev\fR;
.IP
\fBDOUBLE PRECISION\fR for \fBdggev\fR. 
.IP
Arrays, \fBDIMENSION\fR at least max(1, \fIn\fR) each. Contain values that form generalized eigenvalues in real flavors. 
.IP
See \fIbeta\fR.
.TP 10
\fBalpha\fR
.NL
\fBCOMPLEX\fR for \fBcggev\fR;
.IP
\fBDOUBLE COMPLEX\fR for \fBzggev\fR. 
.IP
Array, \fBDIMENSION\fR at least max(1, \fIn\fR). Contain values that form generalized eigenvalues in complex flavors. See \fIbeta\fR.
.TP 10
\fBbeta\fR
.NL
\fBREAL\fR for \fBsggev\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdggev\fR
.IP
\fBCOMPLEX\fR for \fBcggev\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzggev\fR. 
.IP
Array, \fBDIMENSION\fR at least max(1, \fIn\fR).
.IP
\fIFor real flavors\fR:
.IP
On exit, (\fIalphar\fR(j)+ \fIalphai\fR(j)*i)/\fIbeta\fR(j), j=1,..., \fIn\fR, are the generalized eigenvalues. 
.IP
If \fIalphai\fR(j) is zero, then the j-th eigenvalue is real; if positive, then the j-th and (j+1)-st eigenvalues are a complex conjugate pair, with \fIalphai\fR(j+1) negative.
.IP
\fIFor complex flavors:\fR
.IP
On exit, \fIalpha\fR(j)/\fIbeta\fR(j), j=1,..., \fIn\fR, are the generalized eigenvalues. 
.TP 10
\fBvl\fR, \fBvr\fR
.NL
\fBREAL\fR for \fBsggev\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdggev\fR
.IP
\fBCOMPLEX\fR for \fBcggev\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzggev\fR. 
.IP
Arrays:
.IP
\fIvl\fR(\fIldvl\fR,*); the second dimension of \fIvl\fR must be at least max(1, \fIn\fR).
.IP
If \fIjobvl\fR = \fB\'V\'\fR, the left generalized eigenvectors \fIu\fR(j) are stored one after another in the columns of \fIvl\fR, in the same order as their eigenvalues. Each eigenvector is scaled so the largest component has abs(Re) + abs(Im) = 1. 
.IP
If \fIjobvl\fR = \fB\'N\'\fR, \fIvl\fR is not referenced. 
.IP
\fIFor real flavors\fR:
.IP
If the j-th eigenvalue is real, then \fIu\fR(j) = \fIvl\fR(:,j), the j-th column of \fIvl\fR. 
.IP
If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then \fIu\fR(j) = \fIvl\fR(:,j) + \fIi\fR*\fIvl\fR(:,j+1) and \fIu\fR(j+1) = \fIvl\fR(:,j) - \fIi\fR*\fIvl\fR(:,j+1),  where \fIi\fR = sqrt(-1).
.IP
\fIFor complex flavors\fR: 
.IP
\fIu\fR(j) = \fIvl\fR(:,j), the j-th column of \fIvl\fR.
.IP
\fIvr\fR(\fIldvr\fR,*); the second dimension of \fIvr\fR must be at least max(1, \fIn\fR).
.IP
If \fIjobvr\fR = \fB\'V\'\fR, the right generalized eigenvectors \fIv\fR(j) are stored one after another in the columns of \fIvr\fR, in the same order as their eigenvalues. Each eigenvector is scaled so the largest component has abs(Re) + abs(Im) = 1. 
.IP
If \fIjobvr\fR = \fB\'N\'\fR, \fIvr\fR is not referenced. 
.IP
\fIFor real flavors\fR:
.IP
If the j-th eigenvalue is real, then \fIv\fR(j) = \fIvr\fR(:,j), the j-th column of \fIvr\fR. 
.IP
If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then \fIv\fR(j) = \fIvr\fR(:,j) + \fIi\fR*\fIvr\fR(:,j+1) and \fIv\fR(j+1) = \fIvr\fR(:,j) - \fIi\fR*\fIvr\fR(:,j+1). 
.IP
\fIFor complex flavors\fR: 
.IP
\fIv\fR(j) = \fIvr\fR(:,j), the j-th column of \fIvr\fR.
.TP 10
\fBwork(1)\fR
.NL
On exit, if \fIinfo\fR = 0, then \fIwork(1)\fR returns the required minimal size of \fIlwork\fR.
.TP 10
\fBinfo\fR
.NL
\fBINTEGER\fR. 
.IP
If \fIinfo\fR = 0, the execution is successful.
.IP
If \fIinfo\fR = \fI-i\fR, the \fIi-\fRth parameter had an illegal value.
.IP
If \fIinfo\fR = \fIi\fR, and
.IP
\fIi\fR\(<=\fIn\fR: the \fIQZ\fR iteration failed. No eigenvectors have been calculated, but \fIalphar\fR(j), \fIalphai\fR(j) (for real flavors), or \fIalpha\fR(j) (for complex flavors), and \fIbeta\fR(j), j=\fIinfo\fR+1,..., \fIn\fR should be correct.
.IP
\fIi\fR > \fIn\fR: errors that usually indicate LAPACK problems:
.IP
\fIi\fR = \fIn\fR+1: other than \fIQZ\fR iteration failed in \fB?hgeqz\fR;
.IP
\fIi\fR = \fIn\fR+2: error return from \fB?tgevc\fR.
.SH FORTRAN 95 INTERFACE NOTES
.PP
.PP
Routines in Fortran 95 interface have fewer arguments in the calling sequence than their Fortran 77 counterparts. For general conventions applied to skip redundant or restorable arguments, see Fortran 95  Interface Conventions.
.PP
Specific details for the routine \fBggev\fR interface are the following:
.TP 10
\fBa\fR
.NL
Holds the matrix \fIA\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBb\fR
.NL
Holds the matrix \fIB\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBalphar\fR
.NL
Holds the vector of length (\fIn\fR). Used in real flavors only.
.TP 10
\fBalphai\fR
.NL
Holds the vector of length (\fIn\fR). Used in real flavors only.
.TP 10
\fBalpha\fR
.NL
Holds the vector of length (\fIn\fR). Used in complex flavors only.
.TP 10
\fBbeta\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBvl\fR
.NL
Holds the matrix \fIVL\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBvr\fR
.NL
Holds the matrix \fIVR\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBjobvl\fR
.NL
Restored based on the presence of the argument \fIvl\fR as follows: 
.IP
\fIjobvl\fR = \fB\'V\'\fR, if \fIvl\fR is present, 
.IP
\fIjobvl\fR = \fB\'N\'\fR, if \fIvl\fR is omitted.
.TP 10
\fBjobvr\fR
.NL
Restored based on the presence of the argument \fIvr\fR as follows: 
.IP
\fIjobvr\fR = \fB\'V\'\fR, if \fIvr\fR is present, 
.IP
\fIjobvr\fR = \fB\'N\'\fR, if \fIvr\fR is omitted.
