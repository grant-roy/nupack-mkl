.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?\(ulcommit\(ulHelmholtz\(ul2D/?\(ulcommit\(ulHelmholtz\(ul3D 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
\- Checks consistency and correctness of user\'s data as well as initializes certain data structures required to solve 2D/3D Helmholtz problem.
.SH SYNOPSIS
.PP
\fBvoid d\(ulcommit\(ulHelmholtz\(ul2D\fR(\fBdouble* \fR\fIf, \fR\fBdouble* \fR\fIbd\(ulax, \fR\fBdouble* \fR\fIbd\(ulbx, \fR\fBdouble* \fR\fIbd\(ulay, \fR\fBdouble* \fR\fIbd\(ulby, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIxhandle, \fR\fBint* \fR\fIipar, \fR\fBdouble* \fR\fIdpar, \fR\fBint* \fR\fIstat\fR)\fB;\fR
.PP
\fBvoid s\(ulcommit\(ulHelmholtz\(ul2D\fR (\fBfloat* \fR\fIf, \fR\fBfloat* \fR\fIbd\(ulax, \fR\fBfloat* \fR\fIbd\(ulbx, \fR\fBfloat* \fR\fIbd\(ulay, \fR\fBfloat* \fR\fIbd\(ulby, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIxhandle, \fR\fBint* \fR\fIipar, \fR\fBfloat* \fR\fIspar, \fR\fBint* \fR\fIstat\fR)\fB;\fR
.PP
\fBvoid d\(ulcommit\(ulHelmholtz\(ul3D\fR(\fBdouble* \fR\fIf, \fR\fBdouble* \fR\fIbd\(ulax, \fR\fBdouble* \fR\fIbd\(ulbx, \fR\fBdouble* \fR\fIbd\(ulay, \fR\fBdouble* \fR\fIbd\(ulby, \fR\fBdouble* \fR\fIbd\(ulaz, \fR\fBdouble* \fR\fIbd\(ulbz, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIxhandle, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIyhandle, \fR\fBint* \fR\fIipar, \fR\fBdouble* \fR\fIdpar, \fR\fBint* \fR\fIstat\fR)\fB;\fR
.PP
\fBvoid s\(ulcommit\(ulHelmholtz\(ul3D\fR(\fBfloat* \fR\fIf, \fR\fBfloat* \fR\fIbd\(ulax, \fR\fBfloat* \fR\fIbd\(ulbx, \fR\fBfloat* \fR\fIbd\(ulay, \fR\fBfloat* \fR\fIbd\(ulby, \fR\fBfloat* \fR\fIbd\(ulaz, \fR\fBfloat* \fR\fIbd\(ulbz, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIxhandle, \fR\fBDFTI\(ulDESCIPTOR* \fR\fIyhandle, \fR\fBint* \fR\fIipar, \fR\fBfloat* \fR\fIspar, \fR\fBint* \fR\fIstat\fR)\fB;\fR
.SH INPUT PARAMETERS

.TP 10
\fBf\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR,
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR.  
.IP
Contains the right-hand side of the problem packed in a single vector. 
.IP
The size of the vector for the 2D problem is (\fBnx\fR+1)*(\fBny\fR+1). In this case, the value of the right-hand side in the mesh point (\fIi, j\fR) is stored in \fBf\fR[\fIi+j\fR*(\fBnx\fR+1)] . 
.IP
The size of the vector for the 3D problem is (\fBnx\fR+1)*(\fBny\fR+1)*(\fBnz\fR+1). In this case, value of the right-hand side in the mesh point (\fIi, j, k\fR) is stored in \fBf\fR[\fIi+j\fR*(\fBnx\fR+1)+\fIk\fR*(\fBnx\fR+1)*(\fBny\fR+1)]. 
.IP
Note that to solve the Laplace problem, you should set all the elements of the array \fBf\fR to 0. 
.IP
Note also that the array \fBf\fR may be altered by the routine. To preserve the vector, save it in another memory location. 
.TP 10
\fBipar\fR
.NL
\fBint\fR array of size 128. Contains integer data to be used by Fast Helmholtz Solver (for details, refer to Common Parameters). 
.TP 10
\fBdpar\fR
.NL
\fBdouble\fR array of size 5*\fBnx\fR/2+7 in the 2D case or 5*(\fBnx\fR+\fBny\fR)/2+9 in the 3D case. Contains double-precision data to be used by Fast Helmholtz Solver (for details, refer to Common Parameters). 
.TP 10
\fBspar\fR
.NL
\fBfloat\fR array of size 5*\fBnx\fR/2+7 in the 2D case or 5*(\fBnx\fR+\fBny\fR)/2+9 in the 3D case. Contains single-precision data to be used by Fast Helmholtz Solver (for details, refer to Common Parameters). 
.TP 10
\fBbd\(ulax\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, \fB\fR
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
Contains values of the boundary condition on the leftmost boundary of the domain along \fIx\fR-axis. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul2D\fR, the size of the array is \fBny\fR+1. In case of the Dirichlet boundary condition (value of \fBBCtype\fR[0] is \'D\'), it contains values of the function \fIG\fR(\fBax\fR, \fIy\fR(\fIj\fR)), \fIj\fR=0, ..., \fBny\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[0] is \'N\'), it contains values of the function \fIg\fR(\fBax\fR, \fIy\fR(\fIj\fR)), \fIj\fR=0, ..., \fBny\fR. The value corresponding to the index \fIj\fR is placed in \fBbd\(ulax\fR[\fIj\fR]. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR, the size of the array is (\fBny\fR+1)*(\fBnz\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[0] is \'D\'), it contains values of the function \fIG\fR(\fBax\fR, \fIy\fR(\fIj\fR), \fIz\fR(\fIk\fR)), \fIj\fR=0, ..., \fBny\fR, \fIk\fR=0, ..., \fBnz\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[0] is \'N\'), it contains the values of the function \fIg\fR(\fBax\fR, \fIy\fR(\fIj\fR), \fIz\fR(\fIk\fR)), \fIj\fR=0, ..., \fBny\fR, \fIk\fR=0, ..., \fBnz\fR. The values are packed in the array so that the value corresponding to indices \fI(j, k)\fR is placed in \fBbd\(ulax\fR[\fIj+k\fR*(\fBny\fR+1)]. 
.TP 10
\fBbd\(ulbx\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, \fB\fR
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
Contains values of the boundary condition on the rightmost boundary of the domain along \fIx\fR-axis. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul2D\fR, the size of the array is \fBny\fR+1. In case of the Dirichlet boundary condition (value of \fBBCtype\fR[1] is \'D\'), it contains values of the function \fIG\fR(\fBbx\fR, \fIy\fR(\fIj\fR)), \fIj\fR=0, ..., \fBny\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[1] is \'N\'), it contains values of the function \fIg\fR(\fBbx\fR, \fIy\fR(\fIj\fR)), \fIj\fR=0, ..., \fBny\fR. The value corresponding to the index \fIj\fR is placed in \fBbd\(ulbx\fR[\fIj\fR]. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR, the size of the array is (\fBny\fR+1)*(\fBnz\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[1] is \'D\'), it contains values of the function \fIG\fR(\fBbx\fR, \fIy\fR(\fIj\fR), \fIz\fR(\fIk\fR)), \fIj\fR=0, ..., \fBny\fR, \fIk\fR=0, ..., \fBnz\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[1] is \'N\'), it contains the values of the function \fIg\fR(\fBbx\fR, \fIy\fR(\fBj\fR), \fIz\fR(\fIk\fR)), \fIj\fR=0, ..., \fBny\fR, \fIk\fR=0, ..., \fBnz\fR. The values are packed in the array so that the value corresponding to indices \fI(j, k)\fR is placed in \fBbd\(ulbx\fR[\fIj+k\fR*(\fBny\fR+1)]. 
.TP 10
\fBbd\(ulay\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, \fB\fR
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
Contains values of the boundary condition on the leftmost boundary of the domain along \fIy\fR-axis. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul2D\fR, the size of the array is \fBnx\fR+1. In case of the Dirichlet boundary condition (value of \fBBCtype\fR[2] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR), \fBay\fR), \fIi\fR=0, ..., \fBnx\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[2] is \'N\'), it contains values of the function \fIg\fR(\fIx\fR(\fIi\fR), \fBay\fR), \fIi\fR=0, ..., \fBnx\fR. The value corresponding to the index \fIi\fR is placed in \fBbd\(ulay\fR[\fIi\fR]. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR, the size of the array is (\fBnx\fR+1)*(\fBnz\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[2] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR),\fBay\fR, \fIz\fR(\fIk\fR)), \fIi\fR=0, ..., \fBnx\fR, \fIk\fR=0, ..., \fBnz\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[2] is \'N\'), it contains the values of the function \fIg\fR(\fIx\fR(\fIi\fR),\fBay\fR, \fIz\fR(\fIk\fR)), \fIi\fR=0, ..., \fBnx\fR, \fIk\fR=0, ..., \fBnz\fR. The values are packed in the array so that the value corresponding to indices \fI(i, k)\fR is placed in \fBbd\(ulay\fR[\fIi+k\fR*(\fBnx\fR+1)]. 
.TP 10
\fBbd\(ulby\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, \fB\fR
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
Contains values of the boundary condition on the rightmost boundary of the domain along \fIy\fR-axis. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul2D\fR, the size of the array is \fBnx\fR+1. In case of the Dirichlet boundary condition (value of \fBBCtype\fR[3] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR), \fBby\fR), \fIi\fR=0, ..., \fBnx\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[3] is \'N\'), it contains values of the function \fIg\fR(\fIx\fR(\fIi\fR), \fBby\fR), \fIi\fR=0, ..., \fBnx\fR. The value corresponding to the index \fIi\fR is placed in \fBbd\(ulby\fR[\fIi\fR]. 
.IP
For \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR, the size of the array is (\fBnx\fR+1)*(\fBnz\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[3] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR),\fBby\fR, \fIz\fR(\fIk\fR)), \fIi\fR=0, ..., \fBnx\fR, \fIk\fR=0, ..., \fBnz\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[3] is \'N\'), it contains the values of the function \fIg\fR(\fIx\fR(\fIi\fR),\fBby\fR, \fIz\fR(\fIk\fR)), \fIi\fR=0, ..., \fBnx\fR, \fIk\fR=0, ..., \fBnz\fR. The values are packed in the array so that the value corresponding to indices \fI(i, k)\fR is placed in \fBbd\(ulby\fR[\fBi+k\fR*(\fBnx\fR+1)]. 
.TP 10
\fBbd\(ulaz\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, 
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
This parameter is needed only for \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR. Contains values of the boundary condition on the leftmost boundary of the domain along \fIz\fR-axis. 
.IP
The size of the array is (\fBnx\fR+1)*(\fBny\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[4] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR), \fIy\fR(\fIj\fR),\fBaz\fR), \fIi\fR=0, ..., \fBnx\fR, \fIj\fR=0, ..., \fBny\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[4] is \'N\'), it contains the values of the function \fIg\fR(\fIx\fR(\fIi\fR), \fIy\fR(\fIj\fR),\fBaz\fR), \fIi\fR=0, ..., \fBnx\fR, \fIj\fR=0, ..., \fBny\fR. The values are packed in the array so that the value corresponding to indices \fI(i, j)\fR is placed in \fBbd\(ulaz\fR[\fIi+j\fR*(\fBnx\fR+1)]. 
.TP 10
\fBbd\(ulbz\fR
.NL
\fBdouble*\fR for \fBd\(ulcommit\(ulHelmholtz\(ul2D/d\(ulcommit\(ulHelmholtz\(ul3D\fR, \fB\fR
.IP
\fBfloat*\fR for \fBs\(ulcommit\(ulHelmholtz\(ul2D/s\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.IP
This parameter is needed only for \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR. Contains values of the boundary condition on the rightmost boundary of the domain along \fIz\fR-axis. 
.IP
The size of the array is (\fBnx\fR+1)*(\fBny\fR+1). In case of the Dirichlet boundary condition (value of \fBBCtype\fR[5] is \'D\'), it contains values of the function \fIG\fR(\fIx\fR(\fIi\fR), \fIy\fR(\fIj\fR),\fBbz\fR), \fIi\fR=0, ..., \fBnx\fR, \fIj\fR=0, ..., \fBny\fR. In case of the Neumann boundary condition (value of \fBBCtype\fR[5] is \'N\'), it contains the values of the function \fIg\fR(\fIx\fR(\fIi\fR), \fIy\fR(\fIj\fR),\fBbz\fR), \fIi\fR=0, ..., \fBnx\fR, \fIj\fR=0, ..., \fBny\fR. The values are packed in the array so that the value corresponding to indices \fI(i, j)\fR is placed in \fBbd\(ulbz\fR[\fIi+j\fR*(\fBnx\fR+1)]. 
.SH OUTPUT PARAMETERS

.TP 10
\fBf\fR
.NL
Vector of the right-hand side of the problem. Possibly, altered on output. 
.TP 10
\fBipar\fR
.NL
Contains integer data to be used by Fast Helmholtz Solver. Modified on output as explained in Common Parameters. 
.TP 10
\fBdpar\fR
.NL
Contains double-precision data to be used by Fast Helmholtz Solver. Modified on output as explained in Common Parameters. 
.TP 10
\fBspar\fR
.NL
Contains single-precision data to be used by Fast Helmholtz Solver. Modified on output as explained in Common Parameters. 
.TP 10
\fBxhandle, yhandle\fR
.NL
\fBDESCIPTOR\(ulHANDLE*\fR. Data structures used by the Intel MKL FFT interface (for details, refer to FFT Functions). \fByhandle\fR is used only by \fB?\(ulcommit\(ulHelmholtz\(ul3D\fR. 
.TP 10
\fBstat\fR
.NL
\fBint*\fR. Routine completion status, which is also written to \fBipar[0]\fR. The status should be 0 to proceed to other PL routines. 
.SH RETURN VALUES
.PP

.TP 10
\fBstat\fR= 1
.NL
The routine completed without errors and produced some warnings. 
.TP 10
\fBstat\fR= 0
.NL
The routine successfully completed the task. 
.TP 10
\fBstat\fR= -100
.NL
The routine stopped because an error in the user\'s data was found or the data in the \fBdpar\fR, \fBspar\fR or \fBipar\fR array was altered by mistake. 
.TP 10
\fBstat\fR= -1000
.NL
The routine stopped because of an Intel MKL FFT or TT interface error. 
.TP 10
\fBstat\fR= -10000
.NL
The routine stopped because the initialization failed to complete or the parameter \fBipar\fR[0] was altered by mistake. 
.TP 10
\fBstat\fR= -99999
.NL
The routine failed to complete the task because of a fatal error. 
