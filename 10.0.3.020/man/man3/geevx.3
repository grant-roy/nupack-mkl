.\" Copyright (c) 2002 \- 2008 Intel Corporation
.\" All rights reserved.
.\"
.TH ?geevx 3 "Intel Corporation" "Copyright(C) 2002 \- 2008" "Intel(R) Math Kernel Library"
.SH NAME
?geevx \- Computes the eigenvalues and left and right eigenvectors of a general matrix, with preliminary matrix balancing, and computes reciprocal condition numbers for the eigenvalues and right eigenvectors.
.SH SYNOPSIS
.PP
.B Fortran 77
.PP
\fBcall sgeevx\fR(\fIbalanc\fR, \fIjobvl\fR, \fIjobvr\fR, \fIsense\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIwr\fR, \fIwi\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIilo\fR, \fIihi\fR, \fIscale\fR, \fIabnrm\fR, \fIrconde\fR, \fIrcondv\fR, \fIwork\fR, \fIlwork\fR, \fIiwork\fR, \fIinfo\fR)
.PP
\fBcall dgeevx\fR(\fIbalanc\fR, \fIjobvl\fR, \fIjobvr\fR, \fIsense\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIwr\fR, \fIwi\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIilo\fR, \fIihi\fR, \fIscale\fR, \fIabnrm\fR, \fIrconde\fR, \fIrcondv\fR, \fIwork\fR, \fIlwork\fR, \fIiwork\fR, \fIinfo\fR)
.PP
\fBcall cgeevx\fR(\fIbalanc\fR, \fIjobvl\fR, \fIjobvr\fR, \fIsense\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIw\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIilo\fR, \fIihi\fR, \fIscale\fR, \fIabnrm\fR, \fIrconde\fR, \fIrcondv\fR, \fIwork\fR, \fIlwork\fR, \fIrwork\fR, \fIinfo\fR)
.PP
\fBcall zgeevx\fR(\fIbalanc\fR, \fIjobvl\fR, \fIjobvr\fR, \fIsense\fR, \fIn\fR, \fIa\fR, \fIlda\fR, \fIw\fR, \fIvl\fR, \fIldvl\fR, \fIvr\fR, \fIldvr\fR, \fIilo\fR, \fIihi\fR, \fIscale\fR, \fIabnrm\fR, \fIrconde\fR, \fIrcondv\fR, \fIwork\fR, \fIlwork\fR, \fIrwork\fR, \fIinfo\fR)
.PP
.B Fortran 95
.PP
\fBcall geevx\fR(\fIa\fR, \fIwr\fR, \fIwi\fR[,\fIvl\fR] [,\fIvr\fR] [,\fIbalanc\fR] [,\fIilo\fR] [,\fIihi\fR] [,\fIscale\fR] [,\fIabnrm\fR] [, \fIrconde\fR] [,\fIrcondv\fR] [,\fIinfo\fR])
.PP
\fBcall geevx\fR(\fIa\fR, \fIw\fR[,\fIvl\fR] [,\fIvr\fR] [,\fIbalanc\fR] [,\fIilo\fR] [,\fIihi\fR] [,\fIscale\fR] [,\fIabnrm\fR] [,\fIrconde\fR] [, \fIrcondv\fR] [,\fIinfo\fR])
.SH INPUT PARAMETERS

.TP 10
\fBbalanc\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR, \fB\'P\'\fR, \fB\'S\'\fR, or \fB\'B\'\fR. Indicates how the input matrix should be diagonally scaled and/or permuted to improve the conditioning of its eigenvalues.
.IP
If \fIbalanc\fR = \fB\'N\'\fR, do not diagonally scale or permute; 
.IP
If \fIbalanc\fR = \fB\'P\'\fR, perform permutations to make the matrix more nearly upper triangular. Do not diagonally scale; 
.IP
If \fIbalanc\fR = \fB\'S\'\fR, diagonally scale the matrix, i.e. replace \fIA\fR by \fID\fR*\fIA\fR*inv(\fID\fR), where \fID\fR is a diagonal matrix chosen to make the rows and columns of \fIA\fR more equal in norm. Do not permute; 
.IP
If \fIbalanc\fR = \fB\'B\'\fR, both diagonally scale and permute \fIA\fR.
.IP
Computed reciprocal condition numbers will be for the matrix after balancing and/or permuting. Permuting does not change condition numbers (in exact arithmetic), but balancing does.
.TP 10
\fBjobvl\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR or \fB\'V\'\fR. 
.IP
If \fIjobvl\fR = \fB\'N\'\fR, left eigenvectors of \fIA\fR are not computed; 
.IP
If \fIjobvl\fR = \fB\'V\'\fR, left eigenvectors of \fIA\fR are computed. 
.IP
If \fIsense\fR = \fB\'E\'\fR or \fB\'B\'\fR, then \fIjobvl\fR must be \fB\'V\'\fR.
.TP 10
\fBjobvr\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR or \fB\'V\'\fR. 
.IP
If \fIjobvr\fR = \fB\'N\'\fR, right eigenvectors of \fIA\fR are not computed; 
.IP
If \fIjobvr\fR = \fB\'V\'\fR, right eigenvectors of \fIA\fR are computed. 
.IP
If \fIsense\fR = \fB\'E\'\fR or \fB\'B\'\fR, then \fIjobvr\fR must be \fB\'V\'\fR.
.TP 10
\fBsense\fR
.NL
\fBCHARACTER*1\fR. Must be \fB\'N\'\fR, \fB\'E\'\fR, \fB\'V\'\fR, or \fB\'B\'\fR. Determines which reciprocal condition number are computed.
.IP
If \fIsense\fR = \fB\'N\'\fR, none are computed; 
.IP
If \fIsense\fR = \fB\'E\'\fR, computed for eigenvalues only; 
.IP
If \fIsense\fR = \fB\'V\'\fR, computed for right eigenvectors only; 
.IP
If \fIsense\fR = \fB\'B\'\fR, computed for eigenvalues and right eigenvectors.
.IP
If \fIsense\fR is \fB\'E\'\fR or \fB\'B\'\fR, both left and right eigenvectors must also be computed (\fIjobvl\fR = \fB\'V\'\fR and \fIjobvr\fR = \fB\'V\'\fR).
.TP 10
\fBn\fR
.NL
\fBINTEGER\fR. The order of the matrix \fIA\fR (\fIn\fR\(>= 0). 
.TP 10
\fBa\fR, \fBwork\fR
.NL
\fBREAL\fR for \fBsgeevx\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdgeevx\fR
.IP
\fBCOMPLEX\fR for \fBcgeevx\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzgeevx\fR. 
.IP
Arrays: 
.IP
\fIa\fR(\fIlda\fR,*) is an array containing the \fIn\fR-by-\fIn\fR matrix \fIA\fR. 
.IP
The second dimension of \fIa\fR must be at least max(1, \fIn\fR).
.IP
\fIwork\fR is a workspace array, its dimension max(1, \fBlwork\fR).
.TP 10
\fBlda\fR
.NL
\fBINTEGER\fR. The first dimension of the array \fIa\fR. Must be at least max(1, \fIn\fR).
.TP 10
\fBldvl\fR, \fBldvr\fR
.NL
\fBINTEGER\fR. The leading dimensions of the output arrays \fIvl\fR and \fIvr\fR, respectively. 
.IP
Constraints:
.IP
\fIldvl\fR\(>= 1; \fIldvr\fR\(>= 1. 
.IP
If \fIjobvl\fR = \fB\'V\'\fR, \fIldvl\fR\(>= max(1, \fIn\fR); 
.IP
If \fIjobvr\fR = \fB\'V\'\fR, \fIldvr\fR\(>= max(1, \fIn\fR).
.TP 10
\fBlwork\fR
.NL
\fBINTEGER\fR. 
.IP
The dimension of the array \fIwork\fR. 
.IP
\fIFor real flavors\fR:
.IP
If \fIsense\fR = \fB\'N\'\fR or \fB\'E\'\fR, \fIlwork\fR\(>= max(1, 2\fIn\fR), and if \fIjobvl\fR = \fB\'V\'\fR or \fIjobvr\fR = \fB\'V\'\fR, \fIlwork\fR\(>= 3\fIn\fR; 
.IP
If \fIsense\fR = \fB\'V\'\fR or \fB\'B\'\fR, \fIlwork\fR\(>=\fIn\fR*(\fIn\fR+6). 
.IP
For good performance, \fIlwork\fR must generally be larger.
.IP
\fIFor complex flavors\fR:
.IP
If \fIsense\fR = \fB\'N\'\fRor \fB\'E\'\fR, \fIlwork\fR\(>= max(1, 2\fIn\fR); 
.IP
If \fIsense\fR = \fB\'V\'\fR or \fB\'B\'\fR, \fIlwork\fR\(>=\fIn\fR**2+2\fIn\fR. 	For good performance, \fIlwork\fR must generally be larger.
.IP
If \fIlwork\fR = -1, then a workspace query is assumed; the routine only calculates the optimal size of the \fIwork\fR array, returns this value as the first entry of the \fIwork\fR array, and no error message related to \fIlwork\fR is issued by \fBxerbla\fR.
.TP 10
\fBrwork\fR
.NL
\fBREAL\fR for \fBcgeevx\fR
.IP
\fBDOUBLE PRECISION\fR for \fBzgeevx\fR
.IP
Workspace array, \fBDIMENSION\fR at least max(1, 2\fIn\fR). Used in complex flavors only.
.TP 10
\fBiwork\fR
.NL
\fBINTEGER\fR. 
.IP
Workspace array, \fBDIMENSION\fR at least max(1, 2\fIn\fR-2). Used in real flavors only. Not referenced if \fIsense\fR = \fB\'N\'\fR or \fB\'E\'\fR.
.SH OUTPUT PARAMETERS

.TP 10
\fBa\fR
.NL
On exit, this array is overwritten. 
.IP
If \fIjobvl\fR = \fB\'V\'\fR or \fIjobvr\fR = \fB\'V\'\fR, it contains the real-Schur/Schur form of the balanced version of the input matrix \fIA\fR.
.TP 10
\fBwr\fR, \fBwi\fR
.NL
\fBREAL\fR for \fBsgeevx\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdgeevx\fR
.IP
Arrays, \fBDIMENSION\fR at least max (1, \fIn\fR) each. Contain the real and imaginary parts, respectively, of the computed eigenvalues. Complex conjugate pairs of eigenvalues appear consecutively with the eigenvalue having positive imaginary part first. 
.TP 10
\fBw\fR
.NL
\fBCOMPLEX\fR for \fBcgeevx\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzgeevx\fR. 
.IP
Array, \fBDIMENSION\fR at least max(1, \fIn\fR). Contains the computed eigenvalues. 
.TP 10
\fBvl\fR, \fBvr\fR
.NL
\fBREAL\fR for \fBsgeevx\fR
.IP
\fBDOUBLE PRECISION\fR for \fBdgeevx\fR
.IP
\fBCOMPLEX\fR for \fBcgeevx\fR
.IP
\fBDOUBLE COMPLEX\fR for \fBzgeevx\fR. 
.IP
Arrays:
.IP
\fIvl\fR(\fIldvl\fR,*); the second dimension of \fIvl\fR must be at least max(1, \fIn\fR).
.IP
If \fIjobvl\fR = \fB\'V\'\fR, the left eigenvectors \fIu\fR(j) are stored one after another in the columns of \fIvl\fR, in the same order as their eigenvalues. 
.IP
If \fIjobvl\fR = \fB\'N\'\fR, \fIvl\fR is not referenced. 
.IP
\fIFor real flavors\fR:
.IP
If the j-th eigenvalue is real, then \fIu\fR(j) = \fIvl\fR(:,j), the j-th column of \fIvl\fR. 
.IP
If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then \fIu\fR(j) = \fIvl\fR(:,j) + \fIi\fR*\fIvl\fR(:,j+1) and (j+1) = \fIvl\fR(:,j) - \fIi\fR*\fIvl\fR(:,j+1), where \fIi\fR = sqrt(-1).
.IP
\fIFor complex flavors\fR: 
.IP
\fIu\fR(j) = \fIvl\fR(:,j), the j-th column of \fIvl\fR.
.IP
\fIvr\fR(\fIldvr\fR,*); the second dimension of \fIvr\fR must be at least max(1, \fIn\fR).
.IP
If \fIjobvr\fR = \fB\'V\'\fR, the right eigenvectors \fIv\fR(j) are stored one after another in the columns of \fIvr\fR, in the same order as their eigenvalues. 
.IP
If \fIjobvr\fR = \fB\'N\'\fR, \fIvr\fR is not referenced. 
.IP
\fIFor real flavors\fR:
.IP
If the j-th eigenvalue is real, then \fIv\fR(j) = \fIvr\fR(:,j), the j-th column of \fIvr\fR. 
.IP
If the j-th and (j+1)-st eigenvalues form a complex conjugate pair, then \fIv\fR(j) = \fIvr\fR(:,j) + \fIi\fR*\fIvr\fR(:,j+1) and \fIv\fR(j+1) = \fIvr\fR(:,j) - \fIi\fR*\fIvr\fR(:,j+1), where \fIi\fR = sqrt(-1) .
.IP
\fIFor complex flavors\fR: 
.IP
\fIv\fR(j) = \fIvr\fR(:,j), the j-th column of \fIvr\fR.
.TP 10
\fBilo\fR, \fBihi\fR
.NL
\fBINTEGER\fR. \fIilo\fR and \fIihi\fR are integer values determined when \fIA\fR was balanced. 
.IP
The balanced \fIA\fR(i,j) = 0 if i > j and j = 1,..., \fIilo\fR-1 or i = \fIihi\fR+1,..., \fIn\fR. 
.IP
If \fIbalanc\fR = \fB\'N\'\fR or \fB\'S\'\fR, \fIilo\fR = 1 and \fIihi\fR = \fIn\fR.
.TP 10
\fBscale\fR
.NL
\fBREAL\fR for single-precision flavors
.IP
\fBDOUBLE PRECISION\fR for double-precision flavors. 
.IP
Array, \fBDIMENSION\fR at least max(1, \fIn\fR). Details of the permutations and scaling factors applied when balancing \fIA\fR. 
.IP
If \fIP\fR(j) is the index of the row and column interchanged with row and column j, and \fID\fR(j) is the scaling factor applied to row and column j, then
.IP
\fIscale\fR(j) = \fIP\fR(j), for j = 1,...,\fIilo\fR-1
.IP
= \fID\fR(j), for j = \fIilo\fR,...,\fIihi\fR
.IP
= \fIP\fR(j) for j = \fIihi\fR+1,..., \fIn\fR.
.IP
The order in which the interchanges are made is \fIn\fR to \fIihi\fR+1, then 1 to \fIilo\fR-1.
.TP 10
\fBabnrm\fR
.NL
\fBREAL\fR for single-precision flavors
.IP
\fBDOUBLE PRECISION\fR for double-precision flavors.
.IP
The one-norm of the balanced matrix (the maximum of the sum of absolute values of elements of any column).
.TP 10
\fBrconde\fR, \fBrcondv\fR
.NL
\fBREAL\fR for single precision flavors \fBDOUBLE PRECISION\fR for double precision flavors. 
.IP
Arrays, \fBDIMENSION\fR at least max(1, \fIn\fR) each.
.IP
\fIrconde\fR(j) is the reciprocal condition number of the j-th eigenvalue.
.IP
\fIrcondv\fR(j) is the reciprocal condition number of the j-th right eigenvector.
.TP 10
\fBwork(1)\fR
.NL
On exit, if \fIinfo\fR = 0, then \fIwork(1)\fR returns the required minimal size of \fIlwork\fR.
.TP 10
\fBinfo\fR
.NL
\fBINTEGER\fR. 
.IP
If \fIinfo\fR = 0, the execution is successful.
.IP
If \fIinfo\fR = \fI-i\fR, the \fIi\fRth parameter had an illegal value.
.IP
If \fIinfo\fR = \fIi\fR, 	the \fIQR\fR algorithm failed to compute all the eigenvalues, and no eigenvectors or condition numbers have been computed; elements 1:\fIilo\fR-1 and \fIi\fR+1:\fIn\fR of \fIwr\fR and \fIwi\fR (for real flavors) or \fIw\fR (for complex flavors) contain eigenvalues which have converged.
.SH FORTRAN 95 INTERFACE NOTES
.PP
.PP
Routines in Fortran 95 interface have fewer arguments in the calling sequence than their Fortran 77 counterparts. For general conventions applied to skip redundant or restorable arguments, see Fortran 95  Interface Conventions.
.PP
Specific details for the routine \fBgeevx\fR interface are the following:
.TP 10
\fBa\fR
.NL
Holds the matrix \fIA\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBwr\fR
.NL
Holds the vector of length (\fIn\fR). Used in real flavors only.
.TP 10
\fBwi\fR
.NL
Holds the vector of length (\fIn\fR). Used in real flavors only.
.TP 10
\fBw\fR
.NL
Holds the vector of length (\fIn\fR). Used in complex flavors only.
.TP 10
\fBvl\fR
.NL
Holds the matrix \fIVL\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBvr\fR
.NL
Holds the matrix \fIVR\fR of size (\fIn\fR, \fIn\fR).
.TP 10
\fBscale\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBrconde\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBrcondv\fR
.NL
Holds the vector of length (\fIn\fR).
.TP 10
\fBbalanc\fR
.NL
Must be \fB\'N\'\fR, \fB\'B\'\fR, \fB\'P\'\fR or \fB\'S\'\fR. The default value is \fB\'N\'\fR.
.TP 10
\fBjobvl\fR
.NL
Restored based on the presence of the argument \fIvl\fR as follows: 
.IP
\fIjobvl\fR = \fB\'V\'\fR, if \fIvl\fR is present, 
.IP
\fIjobvl\fR = \fB\'N\'\fR, if \fIvl\fR is omitted.
.TP 10
\fBjobvr\fR
.NL
Restored based on the presence of the argument \fIvr\fR as follows: 
.IP
\fIjobvr\fR = \fB\'V\'\fR, if \fIvr\fR is present, 
.IP
\fIjobvr\fR = \fB\'N\'\fR, if \fIvr\fR is omitted.
.TP 10
\fBsense\fR
.NL
Restored based on the presence of arguments \fIrconde\fR and \fBrcondv\fR as follows: 
.IP
\fIsense\fR = \fB\'B\'\fR, if both \fIrconde\fR and \fIrcondv\fR are present, 
.IP
\fIsense\fR = \fB\'E\'\fR, if \fIrconde\fR is present and \fIrcondv\fR omitted, 
.IP
\fIsense\fR = \fB\'V\'\fR, if \fIrconde\fR is omitted and \fIrcondv\fR present, 
.IP
\fIsense\fR = \fB\'N\'\fR, if both \fIrconde\fR and \fIrcondv\fR are omitted.
